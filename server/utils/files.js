import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, "..", "..");
const PAGES_DIR = path.resolve(ROOT_DIR, "pages");
const CACHE_DIR = path.join(ROOT_DIR, "server", "_app", "_cache");

/**
 * Ensures that the cache directory exists.
 * Creates the directory recursively if it does not exist.
 */
async function ensureCacheDir() {
  try {
    await fs.mkdir(CACHE_DIR, { recursive: true });
  } catch (err) {
    console.error("Failed to create cache directory:", err);
  }
}

ensureCacheDir();

/**
 * Checks if a file exists.
 *
 * @param {string} filePath - Absolute path to the file.
 * @returns {Promise<boolean>} True if the file exists, false otherwise.
 */
export async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Returns an autogenerated component name based on its relative path.
 *
 * @param {string} componentPath - Relative path of the component from the project root.
 * @returns {string} The autogenerated component name (prefixed with '_').
 */
export function getAutogeneratedComponentName(componentPath) {
  const componentName = componentPath.split('/').filter(Boolean).join('-').replace('.html', '');
  return `_${componentName}`;
}

/**
 * Builds the absolute path to a page file.
 *
 * @param {string} pageName - Name of the page folder.
 * @returns {string} Absolute path to the page's HTML file.
 */
export const getPagePath = (pageName) =>
  path.resolve(PAGES_DIR, pageName, "page.html");

/**
 * Retrieves the layout HTML template as a string.
 *
 * @returns {Promise<string>} HTML content of the layout.
 */
export const getLayoutTemplate = async () => {
  const layoutPath = path.resolve(PAGES_DIR, "layout.html");
  return await fs.readFile(layoutPath, "utf-8");
};

/**
 * Recursively reads a directory and returns a list of all files.
 *
 * @param {string} dir - Directory to read.
 * @returns {Promise<Array<{ fullpath: string, name: string, path: string }>>}
 *          An array of objects containing full path, file name, and relative path.
 */
export async function readDirectoryRecursive(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    const fullpath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      files.push(...await readDirectoryRecursive(fullpath));
    } else {
      files.push({
        path: fullpath.replace(ROOT_DIR, ''),
        fullpath,
        name: entry.name,
      });
    }
  }

  return files;
}

/**
 * Determines the component/page name from its full file path.
 *
 * @param {string} fullFilepath - Absolute path of the file.
 * @param {string} fileName - File name.
 * @returns {string} The derived component name.
 */
export const getComponentNameFromPath = (fullFilepath, fileName) => {
  const filePath = fullFilepath.replace(ROOT_DIR + path.sep, "");
  const isPage = filePath.startsWith(path.join("pages", path.sep));
  if (isPage) {
    const segments = filePath.split(path.sep);
    if (segments.length === 2) {
      return segments[0].replace(".html", "");
    } else {
      return segments[segments.length - 2].replace(".html", "");
    }
  }
  return fileName.replace(".html", "");
};

/**
 * Retrieves a cached HTML component from disk if it exists and checks if it is stale.
 *
 * @param {Object} options
 * @param {string} options.componentPath - Unique identifier of the page/component.
 * @param {number} [options.revalidateSeconds=0] - Number of seconds before the cached HTML is considered stale.
 * @returns {Promise<{ html: string|null, isStale?: boolean }>}
 *          - `html`: Cached HTML content, or null if it does not exist.
 *          - `isStale`: True if the cached entry is older than `revalidateSeconds`.
 */
export async function getComponentHtmlDisk({ componentPath, revalidateSeconds = 0 }) {
  const filePath = path.join(CACHE_DIR, encodeURIComponent(componentPath) + ".html");
  const metaPath = filePath + ".meta.json";

  const [ existsHtml, existsMeta ] = await Promise.all([ fileExists(filePath), fileExists(metaPath) ]);

  if (!existsMeta || !existsHtml) {
    return { html: null };
  }

  const [ html, meta ] = await Promise.all([
    fs.readFile(filePath, "utf-8"),
    fs.readFile(metaPath, "utf-8")
  ]).then(([htmlContent, metaContent]) => [htmlContent, JSON.parse(metaContent)]);

  const isStale = Date.now() - meta.generatedAt > revalidateSeconds * 1000;

  return { html, isStale };
}

/**
 * Stores the generated HTML of a component/page on disk along with its timestamp.
 *
 * @param {Object} options
 * @param {string} options.componentPath - Unique identifier of the page/component.
 * @param {string} options.html - Generated HTML content.
 * @returns {Promise<void>} Resolves when the HTML and metadata have been successfully saved.
 */
export async function saveComponentHtmlDisk({ componentPath, html }) {
  const filePath = path.join(CACHE_DIR, encodeURIComponent(componentPath) + ".html");
  const metaPath = filePath + ".meta.json";

  await Promise.all([
    fs.writeFile(filePath, html, "utf-8"),
    fs.writeFile(metaPath, JSON.stringify({ generatedAt: Date.now() }), "utf-8"),
  ]);
}
