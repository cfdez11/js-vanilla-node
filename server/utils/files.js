import fs from "fs/promises";
import path from "path";
import { fileURLToPath, pathToFileURL } from "url";

/**
 * Absolute path of the current file.
 * Used to resolve project root in ESM context.
 * @private
 */
const __filename = fileURLToPath(import.meta.url);
/**
 * Directory name of the current module.
 * @private
 */
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, "..", "..");
const PAGES_DIR = path.resolve(ROOT_DIR, "pages");
const SERVER_DIR = path.join(ROOT_DIR, "server");
export const CLIENT_DIR = path.join(ROOT_DIR, "public");
const CLIENT_APP_DIR = path.join(CLIENT_DIR, "_app");
const SERVER_APP_DIR = path.join(SERVER_DIR, "_app");
const CACHE_DIR = path.join(SERVER_APP_DIR, "_cache");
const CLIENT_COMPONENTS_DIR = path.join(CLIENT_APP_DIR, "_components");
const COMPONENTS_DIR = path.join(SERVER_DIR, "components");

/**
 * Ensures all required application directories exist.
 *
 * This function initializes:
 * - Client application directory
 * - Server application directory
 * - Server-side HTML cache directory
 *
 * Directories are created recursively and safely if they already exist.
 *
 * @async
 * @private
 * @returns {Promise<boolean|undefined>}
 * Resolves `true` when directories are created successfully.
 */
export async function initializeDirectories() {
  try {
    await Promise.all([
      fs.mkdir(CLIENT_APP_DIR, { recursive: true }),
      fs.mkdir(SERVER_APP_DIR, { recursive: true }),
      fs.mkdir(CACHE_DIR, { recursive: true }),
      fs.mkdir(CLIENT_COMPONENTS_DIR, { recursive: true })
    ]);

    return true;
  } catch (err) {
    console.error("Failed to create cache directory:", err);
  }
}

/**
 * Normalizes file content before persisting it to disk.
 *
 * - Converts Windows line endings to Unix
 * - Collapses multiple whitespace characters
 * - Trims leading and trailing whitespace
 *
 * Used mainly for generated artifacts (HTML, JS).
 *
 * @param {string} content
 * Raw file content.
 *
 * @returns {string}
 * Normalized content.
 */
function formatFileContent(content) {
  return content
    .trim();
}

/**
 * Writes formatted content to disk.
 *
 * Automatically normalizes content before writing.
 *
 * @async
 * @param {string} filePath
 * Absolute path to the output file.
 *
 * @param {string} content
 * File content to write.
 *
 * @returns {Promise<void>}
 */
export async function writeFile(filePath, content) {
  const formattedContent = formatFileContent(content);
  return fs.writeFile(filePath, formattedContent, 'utf-8');
}

/**
 * Reads a UTF-8 encoded file from disk.
 *
 * @async
 * @param {string} filePath
 * Absolute path to the file.
 *
 * @returns {Promise<string>}
 * File contents.
 */
export function readFile(filePath) {
  return fs.readFile(filePath, 'utf-8');
}


/**
 * Checks whether a file exists and is accessible.
 *
 * @async
 * @param {string} filePath
 * Absolute path to the file.
 *
 * @returns {Promise<boolean>}
 * True if the file exists, false otherwise.
 */
export async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Generates a stable, filesystem-safe component identifier
 * from a relative component path.
 *
 * This name is used to:
 * - Create client-side JS module filenames
 * - Reference client components during hydration
 *
 * @param {string} componentPath
 * Relative path to the component from project root.
 *
 * @returns {string}
 * Autogenerated component name prefixed with `_`.
 */
export function getAutogeneratedComponentName(componentPath) {
  const componentName = componentPath
    .replace(ROOT_DIR + path.sep, '')
    .split(path.sep)
    .filter(Boolean)
    .join('_')
    .replace('.html', '')
    .replace(path.sep, '_')
    .replace('-', '_')
    .replace(':', '_');

  return `_${componentName}`;
}

/**
 * Resolves the absolute path to a page's main HTML file.
 *
 * @param {string} pageName
 * Page directory name.
 *
 * @returns {string}
 * Absolute path to `page.html`.
 */
export const getPagePath = (pageName) =>
  path.resolve(PAGES_DIR, pageName, "page.html");

/**
 * Retrieves the global layout HTML template.
 *
 * @async
 * @returns {Promise<string>}
 * Layout HTML content.
 */
export const getLayoutTemplate = async () => {
  const layoutPath = path.resolve(PAGES_DIR, "layout.html");
  return await fs.readFile(layoutPath, "utf-8");
};

/**
 * Recursively scans a directory and returns all files found.
 *
 * Each file entry includes:
 * - Absolute path
 * - Relative project path
 * - File name
 *
 * @async
 * @param {string} dir
 * Directory to scan.
 *
 * @returns {Promise<Array<{
 *   fullpath: string,
 *   name: string,
 *   path: string
 * }>>}
 */
export async function readDirectoryRecursive(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    const fullpath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      files.push(...await readDirectoryRecursive(fullpath));
    } else {
      files.push({
        path: fullpath.replace(ROOT_DIR, ''),
        fullpath,
        name: entry.name,
      });
    }
  }

  return files;
}

/**
 * Derives a component or page name from its filesystem path.
 *
 * Handles:
 * - Pages inside `/pages`
 * - Nested routes
 * - Standalone components
 *
 * @param {string} fullFilepath
 * Absolute file path.
 *
 * @param {string} fileName
 * File name.
 *
 * @returns {string}
 * Derived component name.
 */

export const getComponentNameFromPath = (fullFilepath, fileName) => {
  const filePath = fullFilepath.replace(ROOT_DIR + path.sep, "");
  const isPage = filePath.startsWith(path.join("pages", path.sep));
  if (isPage) {
    const segments = filePath.split(path.sep);
    if (segments.length === 2) {
      return segments[0].replace(".html", "");
    } else {
      return segments[segments.length - 2].replace(".html", "");
    }
  }
  return fileName.replace(".html", "");
};

/**
 * Retrieves cached HTML for a component or page from disk.
 *
 * Supports ISR by checking whether the cached entry
 * is stale based on `revalidateSeconds`.
 *
 * @async
 * @param {{
 *   componentPath: string,
 *   revalidateSeconds?: number
 * }} options
 *
 * @returns {Promise<{
 *   html: string | null,
 *   isStale?: boolean
 * }>}
 */
export async function getComponentHtmlDisk({ componentPath, revalidateSeconds = 0 }) {
  const filePath = path.join(CACHE_DIR, encodeURIComponent(componentPath) + ".html");
  const metaPath = filePath + ".meta.json";

  const [existsHtml, existsMeta] = await Promise.all([fileExists(filePath), fileExists(metaPath)]);

  if (!existsMeta || !existsHtml) {
    return { html: null };
  }

  const [html, meta] = await Promise.all([
    fs.readFile(filePath, "utf-8"),
    fs.readFile(metaPath, "utf-8")
  ]).then(([htmlContent, metaContent]) => [htmlContent, JSON.parse(metaContent)]);

  const isStale = Date.now() - meta.generatedAt > revalidateSeconds * 1000;

  return { html, isStale };
}

/**
 * Persists server-rendered HTML to disk along with metadata.
 *
 * Metadata includes:
 * - Generation timestamp
 *
 * @async
 * @param {{
 *   componentPath: string,
 *   html: string
 * }} options
 *
 * @returns {Promise<void>}
 */
export async function saveComponentHtmlDisk({ componentPath, html }) {
  const filePath = path.join(CACHE_DIR, encodeURIComponent(componentPath) + ".html");
  const metaPath = filePath + ".meta.json";

  await Promise.all([
    writeFile(filePath, html, "utf-8"),
    writeFile(metaPath, JSON.stringify({ generatedAt: Date.now() }), "utf-8"),
  ]);
}

/**
 * Writes the server-side routes definition file.
 *
 * This file is consumed at runtime by the server router.
 *
 * @async
 * @param {string[]} serverRoutes
 * Serialized server route objects.
 *
 * @returns {Promise<void>}
 */

export async function saveServerRoutesFile(serverRoutes) {
  const commentsServer = `
      /**
       * @typedef {Object} RouteMeta
       * @property {boolean} ssr
       * @property {boolean} requiresAuth
       * @property {number} revalidateSeconds
       */
  
      /**
       * @typedef {Object} Route
       * @property {string} path
       * @property {string} serverPath
       * @property {boolean} isNotFound
       * @property {RouteMeta} meta
       */
    `;

  await writeFile(
    path.join(SERVER_APP_DIR, "_routes.js"), `
      ${commentsServer}
      export const routes = [
        ${serverRoutes.join(",\n")}
      ];
      `
  );
}

/**
 * Writes the client-side routes definition file.
 *
 * Includes:
 * - Route definitions
 * - Client component imports
 *
 * @async
 * @param {string[]} clientRoutes
 * Serialized client route objects.
 *
 * @param {Array<{ varName: string, path: string }>} clientImports
 *
 * @returns {Promise<void>}
 */
export async function saveClientRoutesFile(clientRoutes, clientImports) {
  const commentsClient = `
    /**
     * @typedef {Object} RouteMeta
     * @property {boolean} ssr
     * @property {boolean} requiresAuth
     * @property {number} revalidateSeconds
     */

    /**
     * @typedef {Object} Route
     * @property {string} path
     * @property {string} serverPath
     * @property {boolean} isNotFound
     * @property {(marker: HTMLElement) => void} [component]
     * @property {RouteMeta} meta
     */
  `;
  const clientFileCode = `
    ${clientImports.map(
    (i) => `import * as ${i.varName} from "${i.path}";`
  )
      .join("\n")}

    ${commentsClient}
    export const routes = [
      ${clientRoutes.join(",\n")}
    ];
  `;

  await writeFile(
    path.join(CLIENT_APP_DIR, "_routes.js"),
    clientFileCode
  );
}

/**
 * Converts a page file path into a public-facing route path.
 *
 * Keeps dynamic segments in `[param]` format.
 *
 * @param {string} filePath
 * Absolute page file path.
 *
 * @returns {string}
 * Public route path.
 */

export function getOriginalRoutePath(filePath) {
  let route = filePath.replace(PAGES_DIR, '').replace('/page.html', '');
  if (!route.startsWith('/')) route = '/' + route;
  return route;
}

/**
 * Retrieves all page files (`page.html`) in the pages directory.
 *
 * @async
 * @returns {Promise<Array<{ fullpath: string, path: string }>>}
 */
export async function getPageFiles() {
  const pageFiles = await readDirectoryRecursive(PAGES_DIR);
  const htmlFiles = pageFiles.filter((file) =>
    file.fullpath.endsWith("page.html")
  );

  return htmlFiles;
}

/**
 * Retrieves all component HTML files.
 *
 * @async
 * @returns {Promise<Array<{ fullpath: string, path: string }>>}
 */
export async function getComponentFiles() {
  const componentFiles = await readDirectoryRecursive(COMPONENTS_DIR);
  const htmlFiles = componentFiles.filter((file) =>
    file.fullpath.endsWith(".html")
  );

  return htmlFiles;
}

/**
 * Converts a page file path into a server routing path.
 *
 * Dynamic segments `[param]` are converted to `:param`
 * for Express-style routing.
 *
 * @param {string} filePath
 * Absolute page file path.
 *
 * @returns {string}
 * Server route path.
 */
export function getRoutePath(filePath) {
  let route = filePath.replace(PAGES_DIR, '').replace('/page.html', '');
  route = route.replace(/\[([^\]]+)\]/g, ':$1'); // [param] -> :param

  if (!route.startsWith('/')) {
    route = '/' + route;
  }

  return route;
}

/**
 * Writes a client component JS module to disk.
 *
 * @async
 * @param {string} componentName
 * Autogenerated component name.
 *
 * @param {string} jsModuleCode
 * JavaScript module source.
 *
 * @returns {Promise<void>}
 */
export async function saveClientComponentModule(componentName, jsModuleCode) {
  const outputPath = path.join(CLIENT_COMPONENTS_DIR, `${componentName}.js`);

  await writeFile(outputPath, jsModuleCode, "utf-8");
}

/**
 * Resolves an import path relative to the project root
 * and returns filesystem and file URL representations.
 *
 * @param {string} importPath
 * Import path as declared in source code.
 *
 * @returns {{
 *   path: string,
 *   fileUrl: string,
 *   importPath: string
 * }}
 */
export async function getImportData(importPath) {
  const resolvedPath = path.resolve(ROOT_DIR, importPath);
  const fileUrl = pathToFileURL(resolvedPath).href;

  return { path: resolvedPath, fileUrl, importPath };
}